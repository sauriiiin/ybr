---
title: "YBR196C-A Mutant Transcriptome"
author: "Saurin Parikh"
date: "10/07/2022"
output:
  html_document:
    toc: true
    number_sections: false
    toc_float:
      collapsed: false
    toc_depth: 2
    df_print: paged
    highlight: kate
  pdf_document:
    toc: true
    toc_depth: 2
    highlight: breezedark
  fontsize: 13pt
  geometry: margin=0.5in
---
```{r Initialize, message = FALSE, eval=TRUE, include=FALSE}
library(fastqcr)
library(dplyr)
library(stringr)
library(seqinr)
library(DESeq2)
library(Rsubread)
library(pheatmap)
library(ggplot2)
library(ggpubr)
library(gridExtra)
library(edgeR)
library(UpSetR)
library(corrplot)
library(PoiClaClu)
library(RColorBrewer)
library(genefilter)
library(apeglm)
library(clusterProfiler)
library(org.Sc.sgd.db)

`%notin%` <- Negate(`%in%`)
```
# <ins> Introduction </ins>
## YBR196C-A

* “Putative protein of unknown function” - [Saccharomyces Genome Database (SGD)](https://www.yeastgenome.org/locus/S000028534){target="_blank"}
* 150 base pair long
* Artificial overexpression of this gene using a plasmid based system led to increased growth in 3/5 conditions tested^#^
* 3D structure prediction shows that it contains a transmembrane domain^#^
* In vivo analysis for subcellular localization shows that it localizes to the endoplasmic reticulum membrane^#^

 # = [Vakirlis et. al. 2020](https://doi.org/10.1038/s41467-020-14500-z){target="_blank"}

## RNASeq Data

* 4 strains:
    - WT - wild type
    - KAN - traditional KanMX deletion of YBR196C-A
    - CRISPY - CRISPR deletion of YBR196C-A
    - CRISPY.ATG - CRISPR start codon mutation of YBR196C-A
* All strains are BY4742 background with empty expression vector (pBY011)
* Strains grown in liquid media with galactose for ~24 hours and then liquid media with casamino acid + galactose for ~24 hours
* 3 samples (cellular material) per strain sent for strand specific pair-end RNA sequencing (Genewiz Order Number: 30-345558359)
* Library preparation was done using rRNA reduction

# <ins> Raw Read Quality Check </ins>
```{bash unzip raw fastq files, echo=FALSE, eval=FALSE, include=TRUE}
for fn in ~/RNASeq/YBR/fastq_files/YBR3/rawdata/*.fastq.gz;
do
samp=`basename ${fn}`
dir=`dirname ${fn}`
echo "Unzip-ing file ${samp}"
gzip -d ${dir}/${samp}
done
```
## Running FastQC on Raw Data
```{bash FastQC on raw data, eval=FALSE, include=TRUE}
cd ~/RNASeq/FastQC
for fn in ~/RNASeq/YBR/fastq_files/YBR3/rawdata/*.fastq;
do
samp=`basename ${fn}`
dir=`dirname ${fn}`
mkdir -p ${dir}/qc

echo "QC-ing sample ${samp}"
./fastqc ${dir}/${samp} -o ${dir}/qc/ > /dev/null 2>&1
done
cd ~/R/Projects/rnaseek
```
## Raw Data QC Results
```{r Reading Raw Results, echo = FALSE, message=FALSE, error=FALSE, results = 'hide'}
qc.dir <- "~/RNASeq/YBR/fastq_files/YBR2/rawdata/qc"
qc <- qc_aggregate(qc.dir)
qc.files <- list.files(qc.dir, pattern = '.zip')
temp <- qc_read_collection(sprintf('%s/%s', qc.dir, qc.files),
                           sample_names = str_remove(qc.files, '_001_fastqc.zip'),
                           verbose = F)

fileConn<-file("foo.bar")
# writeLines(str_remove(qc.files, '_001_fastqc.zip'), fileConn)
writeLines(unique(str_split(qc.files, '_', simplify = T)[,1]), fileConn)
close(fileConn)
# temp$sequence_length_distribution$Length <- as.integer(strtrim(temp$sequence_length_distribution$Length, 2))
# temp$adapter_content$Position <-  as.integer(strtrim(temp$adapter_content$Position, 2))
```
```{r, echo = FALSE, message=FALSE, error=FALSE}
qc[qc$module == 'Basic Statistics',]
```
```{r, echo = FALSE, message=FALSE, error=FALSE, results = 'hide', out.width = "80%"}
qc_plot_collection(temp,  modules = qc$module[qc$module != c("Basic Statistics")])
```

# <ins> Trimming RAW data </ins>
I chose to:

* crop the 20 bps from the front of the reads - based on the sequence quality results
* limit the cropped reads to 80 bps in order to trim the adapters at the 3-prime end
    
More information on illumina adapter trimming can be found [here](https://support.illumina.com/bulletins/2016/04/adapter-trimming-why-are-adapter-sequences-trimmed-from-only-the--ends-of-reads.html){target="_blank"}.
  
```{bash Trimmomatic, eval=FALSE, include=TRUE}
cd ~/RNASeq/Trimmomatic
for fn in ~/RNASeq/YBR/fastq_files/YBR3/rawdata/*.fastq;
do
samp=`basename ${fn}`
dir=`dirname ${fn}`
dir2=`dirname ${dir}`
mkdir -p ${dir2}/trimmed1

echo "Trimming sample ${samp}"
java -jar ~/RNASeq/Trimmomatic/trimmomatic-0.39.jar SE -threads 12 \
         ${dir}/${samp} \
         ${dir2}/trimmed1/${samp:0:-6}.trimmed.fastq \
         HEADCROP:20 \
         MINLEN:20 > /dev/null 2>&1
done
cd ~/R/Projects/rnaseek
```

## Quality Check the Trimmed Resuls
```{bash FastQC on trimmed results, echo=FALSE, eval=FALSE}
cd ~/RNASeq/FastQC
for fn in ~/RNASeq/YBR/fastq_files/YBR3/trimmed1/*.fastq;
do
samp=`basename ${fn}`
dir=`dirname ${fn}`
mkdir -p ${dir}/qc

echo "QC-ing sample ${samp}"
./fastqc ${dir}/${samp} -o ${dir}/qc/ > /dev/null 2>&1
done
cd ~/R/Projects/rnaseek
```

```{r Reading Adapt Trimmed FastQC Results, echo=FALSE,results='hide', message=FALSE, error=FALSE, eval=TRUE}
qc.dir <- "~/RNASeq/YBR/fastq_files/YBR3/trimmed1/qc"
qc <- qc_aggregate(qc.dir)
qc.files <- list.files(qc.dir, pattern = '.zip')
qc.data <- qc_read_collection(sprintf('%s/%s', qc.dir, qc.files),
                           sample_names = str_remove(qc.files, '_001.trimmed_fastqc.zip'),
                           verbose = F)
# qc.data$sequence_length_distribution$Length <- 
#   as.integer(strtrim(qc.data$sequence_length_distribution$Length, 2))
# qc.data$adapter_content$Position <- 
#   as.integer(strtrim(qc.data$adapter_content$Position, 2))
```
```{r, echo=FALSE,message=FALSE, error=FALSE}
qc[qc$module == 'Basic Statistics',]
```
```{r, echo=FALSE,results='hide', message=FALSE, error=FALSE,out.width="80%"}
qc_plot_collection(qc.data,  modules = qc$module[qc$module != c("Basic Statistics")])
```


## Overrepresented Sequences (ORS)

Overrepresented sequences (ORS) were coming up as 'No Hit' on FastQC results. I saved all the ORS as a fasta file which was then blasted in [SGD](https://www.yeastgenome.org/blast-sgd){target="_blank"}. The hits included ncRNAs and transposable elements.

```{r Finding what the overrepresented sequences are, echo=FALSE, message=FALSE, warning=FALSE}
ors <- qc.data$overrepresented_sequences
sprintf('There are %d overrepresented sequences in total.',
       length(unique(ors$Sequence)))

write.fasta(as.list(unique(ors$Sequence)), names = as.character(1:length(unique(ors$Sequence))),
            file.out = '~/R/Projects/rnaseek/output/ORS.fasta')
```
Below is a screenshot from the result:

<center>

  ![](../input/images/blast_result.png){width=50%}
  
</center>

Based on this result I decided to use a genome annotation file that includes all features for aligning the reads. Once aligned I will focusing on coding sequences for my downstream analysis.

```{python BLASTing ORSs,echo=FALSE, engine.path="~/anaconda3/bin/python3", eval=FALSE, include=FALSE}
import os
from Bio.SeqRecord import SeqRecord
from Bio import SeqIO
from Bio.Blast import NCBIWWW
from Bio.Blast import NCBIXML

in_file = 'ORS.fasta'
out_file = 'blast_results.txt'
dir = '/home/sbp29/R/Projects/rnaseek/output/'

seq = []
for s in SeqIO.parse(os.path.join(dir,in_file),'fasta'):
    seq.append(s)

n = 1000
result = NCBIWWW.qblast('blastn',"nt",seq,hitlist_size = n,nucl_penalty=-3,nucl_reward=1)
blast_records = NCBIXML.read(result)

f = open(os.path.join(dir,out_file),"w+")
for i in range(n):
    f.write("%s\r\n" % blast_records.alignments[i].title)
f.close()
```

```{bash Viewing the BLAST results, echo=FALSE, eval=FALSE}
wc -l ~/R/Projects/rnaseek/output/blast_results.txt
head -5 ~/R/Projects/rnaseek/output/blast_results.txt
```

# <ins> Using minimap2 for aligning reads</ins>
```{bash Aligning using minimap2, eval=FALSE, include=TRUE}
input="foo.bar"
dir=~/RNASeq/YBR/fastq_files/YBR3/rawdata
mkdir -p ${dir}/quant_minimap

while IFS= read -r samp
do
  echo "Processing sample ${samp}"
  ls $dir/$samp*
  ~/minimap2-2.24_x64-linux/minimap2 -ax sr /home/sbp29/RNASeq/YBR/GCF_000146045.2_R64_genomic.fna ${dir}/${samp}_R1_001.fastq ${dir}/${samp}_R2_001.fastq > ${dir}/quant_minimap/${samp}_aln.sam
done < "$input"

```

```{bash STAR Paired-end alignment and read counts, eval=FALSE, include=TRUE}
input="foo.bar"
dir=~/RNASeq/YBR/fastq_files/YBR2/rawdata
mkdir -p ${dir}/quant_star

while IFS= read -r samp
do
  echo "Processing sample ${samp}"
  ls $dir/$samp*
  
  ~/RNASeq/STAR/bin/Linux_x86_64/STAR \
          --runThreadN 8 \
          --runMode alignReads \
          --outFilterMultimapNmax 1 \
          --outSAMtype BAM Unsorted SortedByCoordinate \
          --readFilesIn ${dir}/${samp}_R1_001.fastq ${dir}/${samp}_R2_001.fastq \
          --quantMode GeneCounts \
          --alignMatesGapMax 1000 \
          --twopassMode Basic \
          --outFileNamePrefix ${dir}/quant_star/${samp}_quant \
          --genomeDir ~/RNASeq/YBR/STAR_index \
          --sjdbGTFfile ~/RNASeq/YBR/scer.gtf > /dev/null 2>&1
done < "$input"
```
STAR log for one of the file:
```{bash Reading STAR log, include=TRUE, eval=TRUE}
cat ~/RNASeq/YBR/fastq_files/YBR3/rawdata/quant_star/3SP1_quantLog.final.out
```
Multimapping threshold was set to 1.

```{bash Index using samtools, eval=FALSE}
cd ~/RNASeq/YBR/fastq_files/YBR3/rawdata/quant_star
for fn in *.sortedByCoord.out.bam;
do
samp=`basename ${fn}`
dir=`dirname ${fn}`

echo "Indexing sample ${samp}"
samtools index ${dir}/${samp}
done
cd ~/R/Projects/ybr
```


```{bash Extracting auxotrophy regions samtools, eval=FALSE}
cd ~/RNASeq/YBR/fastq_files/YBR3/rawdata/quant_star
for fn in *.sortedByCoord.out.bam;
do
samp=`basename ${fn}`
dir=`dirname ${fn}`
mkdir -p ${dir}/auxotrophies

echo "Extract LEU2 region from sample ${samp}"
samtools view -h -b ${dir}/${samp} "III:91324-92418" > ${dir}/auxotrophies/LEU2_${samp}
samtools index ${dir}/auxotrophies/LEU2_${samp}

done
cd ~/R/Projects/ybr
```


# <ins> Generating Read Counts </ins>
I used featureCounts to generate read counts from the STAR bam files.
```{r Loading STAR using Rsubread and featureCounts, echo=FALSE, message=FALSE, warning=FALSE}
star.dir <- '~/RNASeq/YBR/fastq_files/YBR3/rawdata/quant_star'
coldata <- read.csv('~/RNASeq/YBR/fastq_files/YBR3/samples.csv', stringsAsFactors = FALSE)
colnames(coldata) <- c('filename','name')
coldata$name <- factor(coldata$name, levels = c("WT_plas","CRISPY","WT","DEL"))
# coldata$name <- factor(coldata$name, levels = c("WT","KAN","CRISPY","CRISPY-ATG"))
# coldata <- coldata %>% filter(str_detect(filename, 'SP'))
coldata$replicate <- as.factor(rep(c(1,2,3),4))
coldata$sample <- paste(coldata$name, coldata$replicate, sep = '_')
rownames(coldata) <- coldata$sample
coldata$files <- file.path(star.dir, sprintf('%s_%s%s',coldata$filename,
                                             'quant' ,'ReadsPerGene.out.tab'))
coldata$bamfiles <- file.path(star.dir, sprintf('%s_quant%s',coldata$filename,
                                                'Aligned.sortedByCoord.out.bam'))
file.exists(coldata$bamfiles)
# props <- propmapped(files=coldata$bamfiles)
# annot <- read.csv(file = '~/RNASeq/YBR/translatome_annotation.csv')
gtf <- file.path('~/RNASeq/YBR/scer.gtf')
fc <- featureCounts(files = coldata$bamfiles,
                    # annot.ext = annot,
                    annot.ext = gtf, isGTFAnnotationFile = TRUE,
                    strandSpecific = 1,
                    isPairedEnd = TRUE,
                    requireBothEndsMapped = TRUE,
                    allowMultiOverlap = FALSE,
                    countMultiMappingReads = FALSE,
                    countChimericFragments = FALSE,
                    minOverlap = 10,
                    nthreads = 8)
save(fc, file = '~/R/Projects/ybr/output/YBR3_featureCount_raw_sgd_is.RData')
load('~/R/Projects/ybr/output/YBR3_featureCount_raw_sgd_is.RData')
cnts <- as.data.frame(fc$counts)
colnames(cnts) <- coldata$sample
# head(cnts, 8)
cnts[rownames(cnts) %in% c('YBR196C', 'YBR196C-A'),]
```
All KAN and CRISPY samples have 0 reads for YBR196C-A as expected.

## Pre-filtering
```{r Pre-filtering, echo=FALSE}
cds <- read.fasta(file = "~/RNASeq/YBR/scer_cds.fa")
cds <- str_remove(names(cds), '_mRNA')
cnts <- cnts[rownames(cnts) %in% cds,]
sprintf('There are %d genes with more than 10 reads in total.' ,sum(rowSums(cnts) >= 10))
sprintf('There are %d genes with more than 10 reads/sample.' ,sum(rowSums(cnts < 10) == 0))

keep <- rowSums(cnts) >= 10
# keep <- rowSums(cnts < 10) == 0
cnts <- cnts[keep,]
```

I first reduce list to just include coding sequences corresponding to Ensembl gene 
predictions using fasta [file from Ensembl](ftp://ftp.ensembl.org/pub/release-100/fasta/saccharomyces_cerevisiae//cds/Saccharomyces_cerevisiae.R64-1-1.cds.all.fa.gz){target="_blank"}. I also did this using the orf_coding_all.fasta [file from SGD](http://sgd-archive.yeastgenome.org/sequence/S288C_reference/orf_dna/orf_coding_all.fasta.gz){target="_blank"} to include all verified, uncharacterized, dubious and transposable element ORFs. This didn't change the downstream results.

I then perform a minimal pre-filtering to keep ORFs that have at least 10 reads in total.

Note that more strict filtering to increase power is automatically applied via independent filtering on the mean of normalized counts within the DESeq results function.

## Pearson correlation of the raw read counts
```{r Raw correlation matrix, echo=FALSE, message=FALSE, warning=FALSE}
# pairs(cnts, pch = 19)
raw.cor <-cor(cnts)
data.frame(raw.cor)
col1 <- colorRampPalette(c("#7F0000", "red", "#FF7F00", "yellow", "white",
                           "cyan", "#007FFF", "blue","#00007F"))
corrplot(raw.cor,
         type="lower", order="original",
         col=col1(10),
         method = 'circle',
         is.corr = FALSE,
         cl.lim = c(round(min(raw.cor),1),1))
```

# <ins> Normalizing counts using DESeq2 </ins>
```{r Loading raw counts to normalized counts, message=FALSE, warning=FALSE}
##### FILTER SAMPLES (OPTIONAL)
cnts <- cnts[,colnames(cnts) %in% coldata$sample[coldata$name %in% c("WT_plas","CRISPY")]]
coldata <- coldata[coldata$name %in% c("WT_plas","CRISPY"),]

dds <- DESeqDataSetFromMatrix(countData = as.matrix(cnts),
                       colData = coldata,
                       design = ~name)
dds <- DESeq(dds)
```

Since tools for differential expression analysis are comparing the counts between sample groups for the same gene, gene length does not need to be accounted for by DESeq.

## Sample Distances

To ensure there is roughly equal contribution from all genes, I use it on the VST data.

* This function calculates a variance stabilizing transformation (VST) from the fitted dispersion-mean relation(s) and then transforms the count data (normalized by division by the size factors), yielding a matrix of values which are now approximately homoskedastic (having constant variance along the range of mean values). The transformation also normalizes with respect to library size

```{r sample distances, message=FALSE, warning=FALSE}
vsd <- vst(dds)
sampleDists <- dist(t(assay(vsd)))
# cor(assay(vsd), method = 'pearson')

sampleDistMatrix <- as.matrix( sampleDists )
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors,
         show_rownames = T,
         show_colnames = T)
```

## Principal Component Analysis (PCA)

PCA is another way to visualize sample-to-sample distances.

```{r PCA plot, message=FALSE, warning=FALSE}
plotPCA(vsd, intgroup = c("name")) +
  geom_text(aes(label = name), position = position_nudge(y = 2))
```

# <ins> Top Variable Genes </ins>
```{r Top variable genes, results='hide', message=FALSE, warning=FALSE}
topVarGenes <- head(order(rowVars(assay(vsd)), decreasing = TRUE), 20)

mat  <- assay(vsd)[ topVarGenes, ]
mat  <- mat - rowMeans(mat)
anno <- as.data.frame(colData(vsd)[,c("replicate","name")])
pheatmap(mat, annotation_col = anno)
```

These are the top variable genes, ie. have the highest variance. Which is not the same as top differentially expressed genes. This is just a good way of visualizing the data and seeing if the samples are clustering as expected.

# <ins> Differential Expression Analysis </ins>
The three YBR196C-A mutant strains are compared to wild type to look for differential expression. I use adjusted p-value cut-off of 0.05 and an absolute log2 fold change of 1 to categorize as a differentially expressed gene (DEG).
```{r DEA, echo=FALSE, message=FALSE, warning=FALSE,eval=TRUE}
res <- data.frame()
for (c in resultsNames(dds)[2:length(resultsNames(dds))]){
  # cat(sprintf('Log fold change, DE, GO and KEGG results for %s.\n',str_remove(c, 'name_')))
  cat(sprintf('Processing %s...\n',str_remove(c, 'name_')))
  temp <- lfcShrink(dds, coef=c, type="apeglm")
  DESeq2::plotMA(temp, ylim = c(-5, 5), main=str_remove(c, 'name_'))
  cat(sprintf('When comparing %s there are %d genes with more than 1 log fold change at FDR of 5%%. With %d upregulated and %d downregulated.\n\n',
          str_remove(c, 'name_'),
          sum(temp$padj < 0.05 & abs(temp$log2FoldChange) >= 1, na.rm = T),
          sum(temp$padj < 0.05 & temp$log2FoldChange >= 1, na.rm = T),
          sum(temp$padj < 0.05 & temp$log2FoldChange <= -1, na.rm = T)))
  temp$orf_name <- rownames(temp)
  rownames(temp) <- NULL
  res <- rbind(res, data.frame(temp, contrast = str_remove(c, 'name_')))
}
degs <- as.data.frame(rbind(cbind(subset(subset(res, padj <= 0.05),
                                         log2FoldChange >= 1), DE='up-regulated'),
                            cbind(subset(subset(res, padj <= 0.05),
                                         log2FoldChange <= -1), DE='down-regulated')))
degs$ORF <- degs$orf_name
sgd.description <- bitr(degs$orf_name, fromType = "ORF",
                                   toType = c("DESCRIPTION"),
                                   OrgDb = org.Sc.sgd.db,
                        drop = FALSE)

degs <- merge(degs, sgd.description, by='ORF', all=TRUE)
write.csv(degs, file = '../output/ybr3_degs2.csv',row.names = FALSE)
write.csv(res, file = '../output/ybr3_res2.csv',row.names = FALSE)
```

Log fold change results for three interactor of YBR196C-A based on Costanzo et. al. 2016 results.

* YHR079C (IRE1)
* YFL031W (HAC1/ERN4/IRE15)
* YJL095W (BCK1/LAS3/SAP3/SLK1/SSP31)

```{r YBR interactor raw counts, echo=FALSE, eval=FALSE}
counts(dds)[rownames(dds) %in% c('YHR079C','YFL031W','YJL095W'),]
res[res$orf_name %in% c('YHR079C','YFL031W','YJL095W'),]
```

## GO Term & KEGG Pathway Enrichment
Up- and down-regulated DEGs are used for GO term and KEGG pathway enrichment. P-value cut-off of 0.05 and false discovery rate of 5% (BH procedure) was used to consider enrichment.
```{r GO and KEGG Enrichment, echo=FALSE,message=FALSE, warning=FALSE,eval=TRUE}
allgenes <- unique(res$orf_name)
allgenes <- bitr(allgenes, fromType = "ORF",
                 toType = c("ENTREZID","GENENAME","ENSEMBL","DESCRIPTION"),
                 OrgDb = org.Sc.sgd.db)

goe <- data.frame()
kegg <- data.frame()
for (c in unique(degs$contrast)) {
  cat(sprintf('Processing %s...\n\n',c))
  for (de in unique(degs$DE[degs$contrast == c])) {
    temp.deg <- degs$orf_name[degs$contrast == c & degs$DE == de]
    temp.deg <- bitr(temp.deg, fromType = "ORF",
                 toType = c("ENTREZID","GENENAME","ENSEMBL"),
                 OrgDb = org.Sc.sgd.db)
    temp.goe <- enrichGO(gene          = temp.deg$ENSEMBL,
                         universe      = allgenes$ENSEMBL,
                         OrgDb         = org.Sc.sgd.db,
                         keyType       = "ENSEMBL",
                         ont           = "ALL",
                         pAdjustMethod = "BH",
                         pvalueCutoff  = 0.05,
                         qvalueCutoff  = 0.05)
    if (dim(temp.goe)[1] == 0) {
      cat(sprintf('There are no GO term enrichment for %s DEGs in %s.\n\n',de,c))
    } else{
      cat(sprintf('Top 5 GO term enrichment of %s DEGs in %s for:\n',de,c))
      cat(sprintf('\t1. Cellular component - %s.\n',
                  paste(head(unique(temp.goe$Description[temp.goe$ONTOLOGY == 'CC']),5),collapse = ', ')))
      cat(sprintf('\t2. Biological process - %s.\n',
                  paste(head(unique(temp.goe$Description[temp.goe$ONTOLOGY == 'BP']),5),collapse = ', ')))
      cat(sprintf('\t3. Molecular function - %s.\n\n',
                  paste(head(unique(temp.goe$Description[temp.goe$ONTOLOGY == 'MF']),5),collapse = ', ')))
      goe <- rbind(goe, data.frame(temp.goe, contrast = c, DE = de))
    }
    
    temp.kegg <- enrichKEGG(gene         = temp.deg$ENSEMBL,
                            universe     = allgenes$ENSEMBL,
                            organism     = 'sce',
                            pAdjustMethod = "BH",
                            pvalueCutoff = 0.05,
                            qvalueCutoff  = 0.05)
    if (dim(temp.kegg)[1] == 0) {
      cat(sprintf('There are no KEGG pathway enriched for %s DEGs in %s.\n\n',de,c))
    } else{
      cat(sprintf('Top 10 KEGG pathway enrichment for %s DEGs in %s are:\n%s.\n\n',
                  de,c,
                  paste(head(unique(temp.kegg$Description),10),collapse = ', ')))
      kegg <- rbind(kegg, data.frame(temp.kegg, contrast = c, DE = de))
    }
  }
  cat(sprintf('Finished processing %s.\n\n----------\n\n',c))
}

goe$GeneRatio <- as.numeric(str_split(goe$GeneRatio,'/',simplify = T)[,1])/
  as.numeric(str_split(goe$GeneRatio,'/',simplify = T)[,2])
goe$BgRatio <- as.numeric(str_split(goe$BgRatio,'/',simplify = T)[,1])/
  as.numeric(str_split(goe$BgRatio,'/',simplify = T)[,2])
goe$GO <- paste0(goe$ONTOLOGY, '_', goe$Description)

kegg$GeneRatio <- as.numeric(str_split(kegg$GeneRatio,'/',simplify = T)[,1])/
  as.numeric(str_split(kegg$GeneRatio,'/',simplify = T)[,2])
kegg$BgRatio <- as.numeric(str_split(kegg$BgRatio,'/',simplify = T)[,1])/
  as.numeric(str_split(kegg$BgRatio,'/',simplify = T)[,2])

write.csv(goe, file = '../output/goenrich.csv')
write.csv(kegg, file = '../output/keggenrich.csv')
```
```{r Compiled GO and KEGG Results,echo=FALSE,eval=FALSE}
sprintf('Combined GO Term Enrichment Results:')
goe
sprintf('Combined KEGG Pathway Enrichment Results:')
kegg
```


